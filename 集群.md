# 负载均衡
集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一台服务器。

负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。

负载均衡器可以用来实现高可用以及伸缩性：
- 高可用：当某个节点故障时，负载均衡器将用户请求转发到另外的节点，从而保证所有服务持续可用。
- 伸缩性：根据系统整体负载情况，可以很容易地添加移除节点。
负载均衡过程包含两个部分
- 根据负载均衡算法得到转发的节点。
- 进行转发

### 负载均衡算法
#### 轮询
轮询算法把每个请求轮询发送到每个服务器上。

![clipboard.png](https://segmentfault.com/img/bVbgrzA)

实际上，由于进程部署环境的不同，每台服务器的处理能力一般也不同，任务处理时间也不尽相同。因此轮询算法策略并不能很好地将任务均摊到各个进程中。 

#### 加权轮询
加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。

![clipboard.png](https://segmentfault.com/img/bVbgrAE)

加权轮询策略考虑了进程处理能力的不同，因此更接近实际的应用。可是，加权派发策略也没有考虑任务处理的要求。

#### 最少链接
由于每个请求的连接时间不一样，使用轮询或者加权轮询算法，可能会让一台服务器当前连接数过大，而另一台服务器的连接小，造成负载不均衡。

最少连接算法就是将请求发送给最少连接数的服务器上。

![clipboard.png](https://segmentfault.com/img/bVbgrAY)

#### 加权最少连接
在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。

#### 随机算法
把请求随机发送到服务器上。

和轮询法类似，该算法比较适合服务器性能差不多的场景。

#### 原地址哈希法
原地址哈希通过堆客户端ip计算哈希值之后，再对服务器数量取模得到目标服务器的序号。

可以保证同一ip的客户端的请求会转发到同一台服务器上，用来实现会话粘滞。

![clipboard.png](https://segmentfault.com/img/bVbgrCN)

### 转发实现
#### HTTP重定向
负载均衡器计算得到服务器的ip之后，将该地址写入HTTP重定向报文中，状态码为302。客户端收到重定向报文之后，需要重新向服务器发起请求。

缺点：
- 需要两次请求，因此访问延迟比较高。
- 重定向服务器的并发能力制约着整个系统的并发处理能力。
- 如果重定向服务器出现故障，站点就会瘫痪。

![clipboard.png](https://segmentfault.com/img/bVbgrEo)

#### DNS域名解析
DNS负载均衡的实现原理是在DNS服务器中为同一个主机名配置多个IP，在应答DNS查询时，DNS服务器对于每个查询将以DNS记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上，使得不同客户端访问不同的服务器，从而达到负载均衡。

![clipboard.png](https://segmentfault.com/img/bVbgrFv)
  
大型网站基本使用了DNS做为第一级负载均衡手段，然后在内部使用其他方式做第二级负载均衡。也就是说，域名解析的结果为内部的负载均衡服务器IP地址。

#### 反向代理
- 正向代理：发生在客户端，由用户主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。
- 反向代理：发生在服务器端，用户不知道反向代理的存在。

反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能达到源服务器。反向代理可以用来进行缓存，日志记录等，同时也可以用来作为负载均衡服务器。

在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外网IP地址，而反向代理服务器需要配置内网和外网两套IP。因为其工作在OSI结构中的应用层，所以基于反向代理服务器的负载均衡也称七层负载均衡。
![clipboard.png](https://segmentfault.com/img/bVbgrHe)

常用的反向代理服务器Nginx,Apache,Haproxy等 

#### 网络层
在操作系统内核获取网络数据包，根据负载均衡算法计算源服务器的IP地址，并修改请求数据包的目的IP地址，最后进行转发。

#### 数据链路层
在链路层根据负载均衡算法计算源服务器的MAC地址，并修改请求数据包的目的MAC地址，并进行转发。


### 一致性hash
一致性hash算法通过一个一致性hash环的数据结构来实现，这个环的起点为0，终点为2^32-1，并且起点跟终点连接，环中间的整数按逆时针发布，故整个环的证书分布范围是[0,2^32-1]。

![clipboard.png](https://segmentfault.com/img/bVbgpKp)
求出机器的哈希值放进hash环中，再求对象的哈希值放入hash环中，在hash环上顺时针查找距离最近的的机器，即这个对象所属的机器。

#### 虚拟节点
通过虚拟节点来解决负载不均很的问题。

将每台机器虚拟成一组虚拟机器，将虚拟机器放置到hash环上，如果需要确定对象的机器，先确定对象的虚拟机器，再由虚拟机器确定无理机器。

更详细的可参考：[一致性Hash(Consistent Hashing)原理剖析][1]

# 集群下的Session管理
一个用户的Session信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的Session信息，那么该用户就需要重新进行登录等操作。

### Sticky Session
将一个用户的所有请求都路由到同一个服务器，这样就可以把用户的Session存放在该服务器中。

缺点：
- 当服务器宕机时，将丢失该服务器上所有的session。

![clipboard.png](https://segmentfault.com/img/bVbgrQ2)

### Session Replicaiton
在服务器之间进行Session的同步操作，每个服务器都有所有用户的Session信息，因此用户可以向任何一个服务器进行请求。

缺点：
- 占用内存过多。
- 同步过程中占用网络带宽以及服务器处理器时间。

![clipboard.png](https://segmentfault.com/img/bVbgrQ2)

### Session Server
使用一个单独的服务器存储Session数据，可以使用传统的mysql，也可以使用Redis或者memcache内存数据库。

优点：
- 为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。

![clipboard.png](https://segmentfault.com/img/bVbgrSD)
